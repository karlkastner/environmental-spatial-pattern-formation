% Tue 31 May 19:23:38 CEST 2022
% Karl KÃ¤stner, Berlin
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%% analyze a pattern generated by the RK-model
function [sp, out] = rk_2d_heterogeneity_analyze(t,z,rk,aniso,p_noise,scalefield)
	out = struct();

	n_oversample = 1;
	nf = 30; % for correlation
	nf_ = 7;

	filename = rk.filename;
	filename = [filename(1:end-4),'-analyzed.mat'];
	if (exist(filename,'file'))
		load(filename,'sp','out');
	else
	 	[b,w,h] = rk.extract2(z(end,:));
	 	b = squeeze(b);
		b  = single(b);
		% transposing, to plot bands parallel to the y-axis
		b = b';

		sp = Spatial_Pattern();
		sp.source.S = rk.psS.a; 
		% TODO no magic numbers
		sp.opt.rmax = 100;
		sp.opt.scalefield = scalefield;
		sp.b = b;
		sp.L = n_oversample*rk.L;
		sp.opt.weight = false;
		sp.analyze_grid();
		sp.fit_parametric_densities();

		% threshold
		b_ = b;
		b_ = b_-min(b_(:));
		b_ = b_/max(b_(:));
		% q = quantile(b(:),pthresh);
		out.b_thresh = (b_>graythresh(b_));
		out.p_thresh = 1-mean(out.b_thresh,'all');

	% generate a pattern with the bandpass filter
	if (~isscalar(rk.p.a))
		a = rk.p.a;
		% since we transposed the pattern, we have to transpose a as well
		a = reshape(a,rk.nx)';
		% a = repmat(a,n_oversample,n_oversample);
		[~,~,f.r] = fourier_axis_2d(n_oversample*rk.L,n_oversample*rk.nx);
		% TODO deconvolve the noise spectrum and refit
		par = sp.stat.fit.radial.bandpass.par;
		Sr_ = bandpass1d_continuous_pdf(f.r,par(1),par(2),true);
		Sr_ = Sr_.*f.r.^p_noise;
		Tr_ = sqrt(Sr_);	
		out.b_bp        = real(ifft2(Tr_.*fft2(a)));
		q               = quantile(out.b_bp(:),out.p_thresh);
		out.b_bp_thresh = out.b_bp > q;
		out.b_overlay   = out.b_thresh + 2*out.b_bp_thresh;

		out.cba(1)   = corr(b(:),out.b_bp(:));
		out.cba(1,2) = corr(b(:),flat(a));

		% spectral coherence
		out.coherence_2d = coherence_2d(a-mean(a,'all'),b-mean(b,'all'),nf);
		out.coherence_r  = coherence_radial(a-mean(a,'all'),b-mean(b,'all'),nf_);

		%$[b,w,h] = rk.extract2(y(end,:));
		%if (length(rk.p.a) ==1)
		infiltration = flat(a.*rk.infiltration_enhancement(b));
		infiltration = infiltration.*flat(h);
		cva_ = std(rk.p.a,[],'all')./mean(rk.p.a,'all');
		cvi  = std(infiltration,[],'all')./mean(infiltration,'all');
		out.relstd = cva_./cvi;
	else
		out.relstd = NaN; 
		out.b_bp = [];
		out.b_bp_thresh = [];
		out.b_overlay = [];
		out.cba = [NaN,NaN];
		out.coherence_2d = [];
		out.coherence_r = [];
	end
	
		% histogram of biomass
		b_ = b;
		b_(b<=0) = sqrt(eps);
		lb = log(b_(:));
		nbin = round(sqrt(length(lb)));
		q = quantile(lb,[1/nbin,1-1/nbin]);		
		out.bhist.x = linspace(min(lb),max(lb),nbin);
		%[mi,max(log(b(:)))];innerspace(0,3*mean(b(:)),50);
		[out.bhist.c] = hist(lb(:),out.bhist.x);
		% note, this is not yet normalized by bin width
		out.bhist.p = out.bhist.c/sum(out.bhist.c);

		% analyze patch size
		ps = struct();
		[ps.pa,ps.area,ps.pr,ps.radius] = patch_size_2d(out.b_thresh);
		out.patch_size = ps;

	out.fi.radial = linspace(0,3.6,360/3);
	out.fi.angular = linspace(-pi,pi,360);
	out.fi.x = out.fi.radial;
	out.fi.y = linspace(-2.5,2.5,500);
	out.xi  = linspace(0,3.5,350);
	[out.Si,out.Ri] = sp.resample_functions(out.xi,out.fi);


if (0)	

	l1c = 1./sp.stat.fc.rr.hp;

	S2hat       = sp.S.hat;
	S2(:,:,idx) = sp.S.bar;

	S1.x(:,idx) = sp.S.rot.x.hat;
	S1.y(:,idx) = sp.S.rot.y.hat;
	S1.r(:,idx) = sp.S.radial.hat;

	% periodictity test result
	pt(idx,1) = sp.stat.p_periodic; 

	if (aniso)
		Sc(idx,1) = sp.stat.Sc.x.(sp.opt.scalefield);
		lc = 1./sp.stat.fc.x.(sp.opt.scalefield);
%		r2(idx,1) = sp.stat.fit.x.phase_drift.stat.r2;
%		r2(idx,1) = NaN;
		r2.phase_drift(idx) = sp.stat.fit.x.phase_drift.stat.goodness.r2;
		r2.bandpass(idx)    = sp.stat.fit.x.bandpass.stat.goodness.r2;
		r2.logn(idx)        = sp.stat.fit.x.logn.stat.goodness.r2;
		r2.gamma(idx)       = sp.stat.fit.x.gamma.stat.goodness.r2;
		r2.white(idx)       = sp.stat.fit.x.white.stat.goodness.r2;
		r2.periodic(idx)    = sp.stat.fit.x.periodic.stat.goodness.r2;
		R         = sp.R.rot.x.hat;
	else
		Sc(idx,1) = sp.stat.Sc.radial.(scalefield);
		lc        = 1./sp.stat.fc.radial.(scalefield);
		r2.phase_drift(idx,1) = sp.stat.fit.radial.phase_drift.stat.goodness.r2;
		r2.bandpass(idx,1) = sp.stat.fit.radial.bandpass.stat.goodness.r2;
		r2.logn(idx) = sp.stat.fit.radial.logn.stat.goodness.r2;
		r2.gamma(idx) = sp.stat.fit.radial.gamma.stat.goodness.r2;
		r2.white(idx) = sp.stat.fit.radial.white.stat.goodness.r2;
		r2.periodic(idx) = sp.stat.fit.radial.periodic.stat.goodness.r2;
		R         = sp.R.radial.hat;
	end

end % if 0
 
		save(filename,'-v7.3','sp','out');
	end % if ~exist filename
end % analyze

